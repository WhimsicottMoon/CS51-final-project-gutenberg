Hello - from /home/aalias/.atom/packages/ide-reason/rls/rls-linux-1.5.2.exe
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"format_width":80,"autoRebuild":true,"per_value_codelens":false,"dependencies_codelens":false,"opens_codelens":false}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","languageId":"ocaml","version":1,"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we use an\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":3,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00381469726562ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":7,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":8,"character":1}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":8,"character":31}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":10,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":10,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":11,"character":23}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":28,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":26,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":27,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":26,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":25,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":22,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":22,"character":5}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":23,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0488758087158ms
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":20,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":15,"character":3}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":13,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":14,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":25,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0190734863281ms
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":26,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":2},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we use a\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":3},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we use \n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":4},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we use\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":5},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we us\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":6},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we u\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":7},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we \n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":8},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, we\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":9},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, w\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":10},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next, \n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":11},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next,\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":12},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Next\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":13},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Nex\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":14},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try Ne\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":15},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try N\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":16},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try \n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":6}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":17},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each \n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":5}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/formatting","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"options":{"tabSize":2,"insertSpaces":true}}}
[server] Got a method textDocument/formatting
[server] processing took 0.00786781311035ms
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":18},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each\n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":21,"character":5}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00476837158203ms
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":29,"character":47}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":24,"character":36}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":25,"character":36}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":42,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":44,"character":25}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":39,"character":11}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0600814819336ms
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":19},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each\n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":20},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done}\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each\n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":21},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each\n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":39,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":22},"contentChanges":[{"text":"open Plplot\n\n(*PART 1: Extract information from files*)\n\n(* List of string lists, each of which contain all the words in a single book *)\nlet all_word_lists = ref []\n\n(* A text file with all the file paths to each book's .txt file *)\nlet file_of_files = \"Comedy.txt\"\n\n(* List of all the books' file paths *)\nlet book_files = ref []\n\n(* Read in one char at a time and split at whitespace to form new words,\n   operates on the text for a single book\n *)\nlet make_string (s : string) : string list =\n  let whitespace = [' '; '\\n'; '\\r'] in\n  let next_file_channel = open_in s in\n  let word_list = ref [] in\n  let next_word = ref \"\" in\n  try\n  while true; do\n    let next_char = input_char next_file_channel in\n    if List.mem next_char whitespace\n      then (word_list := !next_word :: !word_list; next_word := \"\")\n    else next_word := !next_word ^ (Char.escaped next_char)\n    done;\n    !next_word :: !word_list;\n   with End_of_file -> close_in next_file_channel; !next_word :: !word_list ;;\n\n(* Goes through main text file, stores all the book file names,\n  and gives the each book's file path to make_string\n *)\nlet take_input =\n  let ic = open_in file_of_files in\n  try\n    while true; do\n      book_files := !book_files @ [input_line ic]\n    done;\n  with End_of_file -> close_in ic ;\n  all_word_lists := List.map make_string !book_files ;;\n\n\n(*PART 2: Parse strings*)\n\n(* A list of all characters we want to discard, including punctuation, symbols,\n   and numbers, which have ASCII codes 33-64, and 91-96\n *)\nlet to_discard = List.init 32 (fun i -> Char.chr (i + 33))\n                 @ List.init 6 (fun k -> Char.chr (k + 91)) ;;\n\n(* Throws out punctuation, symbols, and numbers *)\nlet process_book (lst : string list) : string list =\n  let process_word (str : string) : string =\n    let lowercase_str = String.lowercase_ascii str in\n    List.fold_right (fun c s -> String.concat  \"\" (String.split_on_char c s))\n                    to_discard lowercase_str in\n    List.fold_right (fun s l -> (process_word s) :: l) lst [] ;;\n\n(* Generates word-frequency hashtables for a single book *)\nlet count_freqs (lst : string list) : (string, int) Hashtbl.t =\n  let frequencies = Hashtbl.create 3 in\n  let add (s : string) : unit =\n    if Hashtbl.mem frequencies s\n      then Hashtbl.replace frequencies s (succ (Hashtbl.find frequencies s))\n    else Hashtbl.add frequencies s 1 in\n  List.iter add lst;\n  Hashtbl.remove frequencies \"\";\n  frequencies ;;\n\n(* Runs count_freqs on every book *)\nlet count_all (master_lst : string list list) : (string, int) Hashtbl.t list =\n  List.map (fun book -> count_freqs (process_book book)) master_lst ;;\n\n\n(* Associates ranks with word-frequency pairings *)\nlet rank_book (tbl : (string, int) Hashtbl.t) : (string * int * int) list =\n  let compare_word_freq (_, f1 : string * int) (_, f2 : string * int) : int =\n    ~-(compare f1 f2) in\n  List.mapi (fun i (w,f) -> w, f, i+1 )\n            (List.sort compare_word_freq\n                       (Hashtbl.fold (fun w f acc -> (w, f) :: acc) tbl [])) ;;\n\n(* Runs rank_book on every book *)\nlet rank_all (all_words : string list list) : (string * int * int) list list =\n  List.map rank_book (count_all all_words) ;;\n\n(* Part 3: Export and Graph Results *)\n\n(* This gives us a list of lists of word, frequency, rank tuples such that each\n   inner list corresponds to a single book's data. This is all the data we need\n   for this part of the code, formatted the way we want.\n *)\nlet nice_lst = rank_all !all_word_lists\n\n(* Writes word frequency rankings to different files for each book *)\nlet export_results =\n  let export_book (i : int) (file_name : string) : unit =\n    let oc = open_out (\"Ranking of \" ^ file_name) in\n    List.iter (fun (w, f, r) -> Printf.fprintf oc \"%d: %s  %d\\n\" r w f)\n              (List.nth nice_lst i);\n    close_out oc in\n  List.iteri export_book !book_files ;;\n\n(* Set up plot boundaries, orientation, and labels; initialize *)\nlet xmin = 0.0 in\nlet xmax = 5.0 in\nlet ymin = 0.0 in\nlet ymax = 5.0 in\nplinit ();\nplsdiori 1.0;\nplenv xmin xmax ymin ymax 0 0 ;\npllab \"log of rank\"\n      \"log of frequency\"\n      (\"Zipf's Law for \" ^ (List.hd (String.split_on_char '.' file_of_files)));\n\n(* Plot each point as log of rank and frequency with plstring, and save\n   the last point in order to connect the dots. Change color with each book\n *)\nlet oldx = ref 0. in\nlet oldy = ref 0. in\nlet colorer = ref 3 in\nlet plotter ((w, f, r) : (string * int * int)) : unit =\n  plcol0 !colorer;\n  let rlog = log10(float_of_int r) in\n  let flog = log10(float_of_int f) in\n  plstring [|rlog|] [|flog|] \"#(728)\";\n  (if !oldy <> 0. then pljoin !oldx !oldy rlog flog;\n  oldx := rlog;\n  oldy := flog;) in\n  List.iter (fun lst -> List.iter plotter lst; colorer := !colorer + 1;)\n            nice_lst ;;\n\n(* Plplot has a lot of options for the pllegend function, so these are all\n   variables that set up the legend followed by running pllegend\n *)\nlet l = List.length !book_files in\nlet text_colors = Array.init l (fun x -> x + 3) in\nlet text = Array.init l (fun x -> List.hd (String.split_on_char '.'\n                                          (List.nth !book_files x))) in\nlet line_colors = Array.init l (fun x -> x + 3) in\nlet line_styles = Array.make l 1 in\nlet line_widths = Array.make l 1.0 in\nlet symbol_colors = Array.init l (fun x -> x + 3) in\nlet opt_array = Array.make l [PL_LEGEND_LINE; PL_LEGEND_SYMBOL] in\nlet symbol_scales = Array.make l 1.0 in\nlet symbol_numbers = Array.make l 3 in\nlet symbols = Array.make l \"#(728)\" in\npllegend [PL_LEGEND_BOUNDING_BOX] []\n         0.0 0.0 0.1 15\n         1 1 0 0\n         opt_array\n         1.0 1.0 2.0\n         1.0 text_colors text\n         [||] [||] [||] [||]\n         line_colors line_styles line_widths\n         symbol_colors symbol_scales symbol_numbers symbols ;;\n"}]}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"position":{"line":39,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/formatting","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml"},"options":{"tabSize":2,"insertSpaces":true}}}
[server] Got a method textDocument/formatting
[server] processing took 0.00500679016113ms
Sending response {"id": 41, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/aalias/cs51psets/CS51-final-project-gutenberg/gutenberg.ml","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
